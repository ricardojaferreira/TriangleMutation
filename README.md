# Triangle - Mutation Tests for TVVS

#### Note about install ANT
* Add the following lines to your shell
    ```
    export PATH="PATH_TO_ANT_BIN_FOLDER:$PATH"
    export ANT_HOME="PATH_TO_ANT_FOLDER"
    ```
### Questions

1) State one advantage and one disadvantage for (1) instrumenting Java source code and (2) instrumenting Java byte code, for the purpose of measuring code 
coverage. Which instrumentation approach is preferable? Briefly explain why?
    * Instrumenting Java Source code is easier for the developer, since the code is easier to understand, on the other hand source code requires compilation
    and the tests are slower and have the compilation overhead.
    Byte code instrumentation can be more reliable since it is the code that the JVM will actually run and the tests will have more performance. Instrumenting 
    byte code can be more time consuming since byte code is not so easy to follow has source code. 
    Regarding which one is preferable, probably byte code, since it test the actual code that runs on the JVM and byte code instrumentation can be generated by 
    automated test tools, making it probably more simpler.
    
2) How many mutants does your coverage-adequate test suite cover and detect?
    * Covered 150 tests and killed 140
    
3) How many additional mutants did you analyze (inspect) to satisfy mutation adequacy?
    * 31 mutants were analyzed
    
4) How many mutants are equivalent? Provide a proof for each equivalent mutant.
    * 7 mutants are equivalent. Check the TriangleTest file for explanation on each one.
    
5) What changes in code coverage ratio and mutation score did you observe after deleting
   the assert statement in the testTriangle method? What are the implications for using the code coverage ratio as an adequacy criterion?
   * After removing the assert statement, the coverage remained the same, but the mutation score was heavily penalized since no mutants were killed. 
   Using code coverage to infer adequacy tells us that our tests have conditions that met all the branchs of our code, but that doesn't mean that the code is
   correct and bug free. Dispite this, code coverage can increase the level of confidence the developers have on the code and is a good indicator of the defect
   density.